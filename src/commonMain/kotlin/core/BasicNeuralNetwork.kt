/*
 * Licensed under the MIT License. See LICENSE file in the project root for full license information.
 */
package core

import koma.create
import koma.extensions.map
import koma.matrix.Matrix
import koma.rand
import koma.zeros
//import kotlin.math.abs
import kotlin.math.sqrt

/**
 * Basic Neural Network consisted only of some layers of neurons.
 *
 * @constructor creates new [BasicNeuralNetwork] with
 * * [numberOfHiddenLayers] hidden layers, which have sizes generated by [sizes]
 * * neurons activating given by [activationFunction]
 * * input for [inputLayerSize] [Double]s
 * * answering with [outputLayerSize] [Double]s
 *
 * @param[numberOfHiddenLayers] number of hidden layers (without input and output layers)
 * @param[activationFunction] how neurons are activated
 * @param[sizes] sizes of hidden layers
 * @param[inputLayerSize] size of input
 * @param[outputLayerSize] size of output
 * @param[weights] list of matrices, which state weights of connections between neurons in previous layer and neurons in next one
 */
class BasicNeuralNetwork(
    private val numberOfHiddenLayers: Int,
    val activationFunction: IActivationFunctions = ActivationFunctions.Sigmoid,
    val sizes: (Int) -> Int = { numberOfHiddenLayers },
    val inputLayerSize: Int = numberOfHiddenLayers,
    val outputLayerSize: Int = numberOfHiddenLayers,
    private val weights: MutableList<Matrix<Double>> = MutableList(numberOfHiddenLayers + 1) {
        if (numberOfHiddenLayers == 0) {
            rand(outputLayerSize, inputLayerSize)
        } else when (it) {
            0 -> rand(sizes(it), inputLayerSize) * (sqrt(2.0 / (sizes(it) + inputLayerSize)))
            numberOfHiddenLayers -> rand(
                outputLayerSize,
                sizes(it - 1)
            ) * (sqrt(2.0 / (outputLayerSize + sizes(it - 1))))
            else -> rand(sizes(it), sizes(it - 1)) * (sqrt(2.0 / (sizes(it) + sizes(it - 1))))
        }
    },
    private val biases: MutableList<Matrix<Double>> = MutableList(numberOfHiddenLayers + 1) {
        //rand(if (it == numberOfHiddenLayers) { outputLayerSize } else { sizes(it) }, 1)
        zeros(
            if (it == numberOfHiddenLayers) {
                outputLayerSize
            } else {
                sizes(it)
            }, 1
        )
    },
    private val values: MutableList<Matrix<Double>> = MutableList(numberOfHiddenLayers + 2) {
        zeros(
            when (it) {
                0 -> inputLayerSize
                numberOfHiddenLayers + 1 -> outputLayerSize
                else -> sizes(it)
            }, 1
        )
    }
) : INeuralNetwork {

    /**
     * [Double] value which declares how quickly weights and biases are changing
     */
    var learningRate = 0.1

    override fun run(input: Matrix<Double>): Matrix<Double> {
        require(inputLayerSize == input.size) { "Wrong size of input! This NN has input size $inputLayerSize, but you offer it input with size ${input.size}." }
        values[0] = input
        for (index in weights.indices) {
            values[index + 1] = (weights[index] * values[index] + biases[index]).map { activationFunction(it) }
        }
        return values.last()
    }

    override fun train(input: Matrix<Double>, output: Matrix<Double>) = train(output - run(input))

    fun train(er: Matrix<Double>): Matrix<Double> {
        var error = er
        for (i in numberOfHiddenLayers downTo 0) {
            val derivations = values[i + 1].map { activationFunction.yD(it) }.elementTimes(error)
            biases[i] += derivations * learningRate
            error = weights[i].T * derivations
            weights[i] += derivations * values[i].T * learningRate
        }
        return error
    }

   override fun save() =
        when (activationFunction) {
            is ActivationFunctions -> "$numberOfHiddenLayers;$activationFunction;${(0..numberOfHiddenLayers + 1).map(
                sizes
            )};$inputLayerSize;$outputLayerSize;${weights.map { it.toList() }};${biases.map { it.toList() }}"
            else -> TODO("It's hard to save unknown function")
        }

    companion object {
        /**
         * Load [BasicNeuralNetwork] from [data]
         */
        fun load(data: String): BasicNeuralNetwork {

            val dataList = data.split(";")
            val numberOfHiddenLayers = dataList[0].toInt()
            val sizeList = dataList[2].removePrefix("[").removeSuffix("]").split(", ").map { it.toInt() }
            val sizes: (Int) -> Int = { sizeList[it] }
            val inputLayerSize = dataList[3].toInt()
            val outputLayerSize = dataList[4].toInt()
            return BasicNeuralNetwork(
                numberOfHiddenLayers,
                try {
                    ActivationFunctions.valueOf(dataList[1])
                } catch (e: Exception) {
                    TODO("It's hard to save unknown function")
                },
                sizes,
                inputLayerSize,
                outputLayerSize,
                dataList[5].removePrefix("[[").removeSuffix("]]").split("], [").mapIndexed
                { index, it ->
                    if (numberOfHiddenLayers == 0) {
                        create(
                            it.split(", ").map { str -> str.toDouble() }.toDoubleArray(),
                            outputLayerSize,
                            inputLayerSize
                        )
                    } else when (index) {
                        0 -> create(
                            it.split(", ").map { str -> str.toDouble() }.toDoubleArray(),
                            sizes(index),
                            inputLayerSize
                        )
                        numberOfHiddenLayers -> create(
                            it.split(", ").map { str -> str.toDouble() }.toDoubleArray(),
                            outputLayerSize,
                            sizes(index - 1)
                        )
                        else -> create(
                            it.split(", ").map { str -> str.toDouble() }.toDoubleArray(),
                            sizes(index),
                            sizes(index - 1)
                        )
                    }
                }.toMutableList(),
                dataList[6].removePrefix("[[").removeSuffix("]]").split("], [").mapIndexed
                { index, it ->
                    create(
                        it.split(", ").map { str -> str.toDouble() }.toDoubleArray(),
                        if (index == numberOfHiddenLayers) {
                            outputLayerSize
                        } else {
                            sizes(index)
                        },
                        1
                    )
                }.toMutableList()
            )
        }
    }
}